#include <Wire.h>
#include <IRremote.h>
#include <INA219.h>
#include <LiquidCrystal_I2C.h>

// ================= 1. 핀 번호 설정 =================
const int PIN_MOSFET = 2;
const int PIN_PWM = 5;
const int PIN_DIR = 6;
const int PIN_IR = 7;

// LCD & 센서
LiquidCrystal_I2C lcd(0x27, 16, 2);
INA219 ina(0x40);

// ================= 2. 리모컨 버튼 =================
#define CMD_OK      0x1C
#define CMD_STOP    0x19
#define CMD_SPEED_1 0x45
#define CMD_SPEED_2 0x46
#define CMD_SPEED_3 0x47

// ================= 3. 속도 설정 =================
const int SPEEDS[4] = {0, 100, 170, 255};  // 0단, 1단, 2단, 3단

// ================= 4. 상태 변수 =================
bool isReady = false;
int currentLevel = 0;

// ================= 5. 3차 편차 최적화 설정 =================
const int CASES[3] = {2000, 4000, 6000};
const int NUM_CASES = 3;
int bestSampleCount[4] = {2000, 2000, 6000, 2000};  // 각 단계별 최적값 (기본값)
bool optimizationDone = false;

// ================= 6. ML 모델 가중치 =================
const float ML_WEIGHTS[4] = {-0.245906, -0.010775, 0.011843, 0.252006};
const float ML_BIASES[4] = {12.194311, -0.226601, -2.158247, -30.530639};

// ================= 7. 자동 꺼짐 설정 =================
const unsigned long AUTO_OFF_DURATION = 60000;
unsigned long standbyStartTime = 0;
bool isInStandby = false;
int predictedLevel = -1;

// ================= 8. 측정 타이밍 =================
unsigned long lastMeasureTime = 0;
const unsigned long MEASURE_INTERVAL = 2000;

// ================= 9. 함수 정의 =================

// 함수 프로토타입 선언
void checkRemote();

void controlFan(int speed) {
  digitalWrite(PIN_DIR, HIGH);
  analogWrite(PIN_PWM, 255 - speed);
}

int predictLevel(float current_mA) {
  float maxScore = -999999;
  int predicted = 0;
  
  for (int i = 0; i < 4; i++) {
    float score = ML_WEIGHTS[i] * current_mA + ML_BIASES[i];
    if (score > maxScore) {
      maxScore = score;
      predicted = i;
    }
  }
  return predicted;
}

// [최적 샘플 수 기반 평균 전류 측정 - 분할 측정]
// 전역 변수로 측정 상태 관리
float measureTotal = 0;
long measureCount = 0;
bool isMeasuring = false;

// 한 번 호출할 때마다 일부만 측정 (200개씩)
bool measureChunk(int level) {
  if (!isMeasuring) {
    // 측정 시작
    measureTotal = 0;
    measureCount = 0;
    isMeasuring = true;
  }
  
  long targetSamples = bestSampleCount[level];
  
  // 2단 제외하고 최대 2000개로 제한 (리모컨 응답성 확보)
  if (level != 2 && targetSamples > 2000) {
    targetSamples = 2000;
  }
  
  long chunkSize = 200;  // 한 번에 200개씩만 측정
  
  for (long i = 0; i < chunkSize && measureCount < targetSamples; i++) {
    measureTotal += ina.getCurrent_mA();
    measureCount++;
    delayMicroseconds(random(100, 500));
  }
  
  // 측정 완료 여부 반환
  if (measureCount >= targetSamples) {
    isMeasuring = false;
    return true;  // 완료
  }
  return false;  // 진행 중
}

float getAverageCurrent() {
  return measureTotal / measureCount;
}

// [리모컨 체크 함수]
void checkRemote() {
  if (IrReceiver.decode()) {
    uint16_t command = IrReceiver.decodedIRData.command;
    
    if (command == 0 || (IrReceiver.decodedIRData.flags & IRDATA_FLAGS_IS_REPEAT)) {
      IrReceiver.resume();
      return;
    }
    
    if (command == CMD_OK) {
      isReady = true;
      isInStandby = false;
      lcd.clear();
      lcd.print("UNLOCKED!");
      Serial.println(">>> UNLOCKED");
      
      // UNLOCKED 후 1초간 추가 입력 대기
      unsigned long waitStart = millis();
      while (millis() - waitStart < 1000) {
        if (IrReceiver.decode()) {
          uint16_t nextCmd = IrReceiver.decodedIRData.command;
          if (nextCmd != 0 && !(IrReceiver.decodedIRData.flags & IRDATA_FLAGS_IS_REPEAT)) {
            if (nextCmd == CMD_SPEED_1) {
              controlFan(SPEEDS[1]);
              currentLevel = 1;
              Serial.println(">>> Speed 1");
            }
            else if (nextCmd == CMD_SPEED_2) {
              controlFan(SPEEDS[2]);
              currentLevel = 2;
              Serial.println(">>> Speed 2");
            }
            else if (nextCmd == CMD_SPEED_3) {
              controlFan(SPEEDS[3]);
              currentLevel = 3;
              Serial.println(">>> Speed 3");
            }
          }
          IrReceiver.resume();
        }
      }
    }
    else if (isReady) {
      if (command == CMD_STOP) {
        controlFan(SPEEDS[0]);
        currentLevel = 0;
        isReady = false;
        isInStandby = false;
        Serial.println(">>> STOP");
      }
      else if (command == CMD_SPEED_1) {
        controlFan(SPEEDS[1]);
        currentLevel = 1;
        isInStandby = false;
        Serial.println(">>> Speed 1");
      }
      else if (command == CMD_SPEED_2) {
        controlFan(SPEEDS[2]);
        currentLevel = 2;
        isInStandby = false;
        Serial.println(">>> Speed 2");
      }
      else if (command == CMD_SPEED_3) {
        controlFan(SPEEDS[3]);
        currentLevel = 3;
        isInStandby = false;
        Serial.println(">>> Speed 3");
      }
    }
    
    IrReceiver.resume();
  }
}

// [단일 레벨에 대한 3차 편차 최적화]
// 편차 차이가 THRESHOLD 이내면 가장 짧은 샘플 수 선택
const float DIFF_THRESHOLD = 0.5;  // 편차 임계값 (조절 가능)

int findOptimalForLevel(int level) {
  double sumSet1[NUM_CASES] = {0};
  double sumSet2[NUM_CASES] = {0};
  double sumSet3[NUM_CASES] = {0};
  double sumSet4[NUM_CASES] = {0};
  
  long sampleCounter = 0;
  long maxSamples = CASES[NUM_CASES - 1] * 4;  // 24000
  
  while (sampleCounter < maxSamples) {
    float val = ina.getCurrent_mA();
    
    for (int i = 0; i < NUM_CASES; i++) {
      int N = CASES[i];
      if (sampleCounter < N) sumSet1[i] += val;
      else if (sampleCounter < N * 2) sumSet2[i] += val;
      else if (sampleCounter < N * 3) sumSet3[i] += val;
      else if (sampleCounter < N * 4) sumSet4[i] += val;
    }
    sampleCounter++;
    
    // 진행률 표시 (6000개마다)
    if (sampleCounter % 6000 == 0) {
      lcd.setCursor(0, 1);
      lcd.print("L");
      lcd.print(level);
      lcd.print(": ");
      lcd.print((sampleCounter * 100) / maxSamples);
      lcd.print("%      ");
    }
    
    delayMicroseconds(random(100, 500));
  }
  
  // 각 Case의 편차 계산
  float totalDiffs[NUM_CASES];
  float minTotalDiff = 999999.0;
  
  Serial.print("  Level ");
  Serial.print(level);
  Serial.println(" results:");
  
  for (int i = 0; i < NUM_CASES; i++) {
    int count = CASES[i];
    float mean1 = sumSet1[i] / count;
    float mean2 = sumSet2[i] / count;
    float mean3 = sumSet3[i] / count;
    float mean4 = sumSet4[i] / count;
    
    float diff1 = abs(mean1 - mean2);
    float diff2 = abs(mean2 - mean3);
    float diff3 = abs(mean3 - mean4);
    totalDiffs[i] = diff1 + diff2 + diff3;
    
    Serial.print("    Case ");
    Serial.print(count);
    Serial.print(": ");
    Serial.println(totalDiffs[i], 4);
    
    if (totalDiffs[i] < minTotalDiff) {
      minTotalDiff = totalDiffs[i];
    }
  }
  
  // 최소 편차와 비슷한 것 중 가장 짧은 샘플 수 선택
  for (int i = 0; i < NUM_CASES; i++) {
    if (totalDiffs[i] - minTotalDiff <= DIFF_THRESHOLD) {
      Serial.print("  -> Selected: ");
      Serial.print(CASES[i]);
      Serial.println(" (within threshold)");
      return CASES[i];
    }
  }
  
  return CASES[0];  // 기본값
}

// [전체 최적화 (3단 → 2단 → 1단 → 0단)]
void runFullOptimization() {
  lcd.clear();
  lcd.print("Optimizing...");
  Serial.println("\n>>> Starting full optimization (3->2->1->0)");
  
  int optimizeOrder[4] = {3, 2, 1, 0};
  
  for (int i = 0; i < 4; i++) {
    int level = optimizeOrder[i];
    
    lcd.setCursor(0, 0);
    lcd.print("Optimize Lv");
    lcd.print(level);
    lcd.print("    ");
    
    Serial.print("\n>>> Optimizing Level ");
    Serial.println(level);
    
    // 해당 단계로 선풍기 설정
    controlFan(SPEEDS[level]);
    delay(5000);  // 안정화 대기
    
    // 2단은 무조건 6000 고정 (실험 결과 가장 안정적)
    if (level == 2) {
      bestSampleCount[level] = 6000;
      Serial.println("  Level 2: Fixed at 6000 (most stable)");
    } else {
      // 나머지는 3차 편차 최적화 수행
      bestSampleCount[level] = findOptimalForLevel(level);
    }
    
    Serial.print("  -> Best: ");
    Serial.println(bestSampleCount[level]);
    
    // 결과 표시
    lcd.setCursor(0, 1);
    lcd.print("Best: ");
    lcd.print(bestSampleCount[level]);
    lcd.print("    ");
    delay(1500);
  }
  
  // 선풍기 정지
  controlFan(SPEEDS[0]);
  optimizationDone = true;
  
  // 최종 결과 표시
  lcd.clear();
  lcd.print("Optimize Done!");
  
  Serial.println("\n>>> Optimization Complete!");
  Serial.println(">>> Best sample counts:");
  for (int i = 0; i < 4; i++) {
    Serial.print("  Level ");
    Serial.print(i);
    Serial.print(": ");
    Serial.println(bestSampleCount[i]);
  }
  
  delay(2000);
}

void updateLCD(float current_mA) {
  lcd.setCursor(0, 0);
  lcd.print("L:");
  lcd.print(currentLevel);
  lcd.print(" ML:");
  lcd.print(predictedLevel);
  lcd.print(" ");
  lcd.print((int)current_mA);
  lcd.print("mA   ");
  
  lcd.setCursor(0, 1);
  if (isInStandby) {
    unsigned long remaining = (AUTO_OFF_DURATION - (millis() - standbyStartTime)) / 1000;
    lcd.print("AutoOff: ");
    lcd.print(remaining);
    lcd.print("s     ");
  } else if (!isReady) {
    lcd.print("Press [OK]      ");
  } else {
    lcd.print("S:");
    lcd.print(bestSampleCount[currentLevel]);
    lcd.print(" Run   ");
  }
}

void autoPowerOff() {
  controlFan(SPEEDS[0]);
  currentLevel = 0;
  isReady = false;
  isInStandby = false;
  
  // MOSFET 전원 차단!
  digitalWrite(PIN_MOSFET, LOW);
  
  lcd.clear();
  lcd.print("AUTO POWER OFF!");
  lcd.setCursor(0, 1);
  lcd.print("MOSFET OFF");
  
  Serial.println(">>> AUTO POWER OFF - MOSFET OFF");
  
  delay(3000);
  
  lcd.clear();
  lcd.print("Press [OK]");
  lcd.setCursor(0, 1);
  lcd.print("to Restart");
}

// ================= SETUP =================
void setup() {
  Serial.begin(9600);
  Wire.begin();
  
  pinMode(PIN_MOSFET, OUTPUT);
  pinMode(PIN_PWM, OUTPUT);
  pinMode(PIN_DIR, OUTPUT);
  
  digitalWrite(PIN_MOSFET, HIGH);
  digitalWrite(PIN_DIR, HIGH);
  analogWrite(PIN_PWM, 255);
  
  IrReceiver.begin(PIN_IR, ENABLE_LED_FEEDBACK);
  
  lcd.init();
  lcd.backlight();
  lcd.clear();
  lcd.print("Smart Fan v3.1");
  lcd.setCursor(0, 1);
  lcd.print("Per-Level Opt");
  
  if (!ina.begin()) {
    lcd.clear();
    lcd.print("INA219 Error!");
    while (1);
  }
  ina.setMaxCurrentShunt(2.5, 0.1);
  
  delay(2000);
  
  // 각 단계별 최적화 실행
  runFullOptimization();
  
  lcd.clear();
  lcd.print("Press [OK]");
  lcd.setCursor(0, 1);
  lcd.print("to Start");
  
  Serial.println("\n>>> System Ready");
  Serial.println("Time,Level,Current,ML,Standby");
}

// ================= LOOP =================
void loop() {
  
  // [기능 1] 리모컨 항상 먼저 체크!
  checkRemote();
  
  // [기능 2] 전류 측정 (분할 방식)
  if (measureChunk(currentLevel)) {
    // 측정 완료되면 ML 예측
    float avgCurrent = getAverageCurrent();
    predictedLevel = predictLevel(avgCurrent);
    
    // 자동 꺼짐 로직 (0단 전류 감지 시) - 먼저 처리!
    if (predictedLevel == 0) {
      if (!isInStandby) {
        isInStandby = true;
        standbyStartTime = millis();
        Serial.println(">>> Standby started");
      } else if (millis() - standbyStartTime >= AUTO_OFF_DURATION) {
        autoPowerOff();
        return;
      }
    } else {
      if (isInStandby) {
        isInStandby = false;
        Serial.println(">>> Standby cancelled");
      }
    }
    
    // 시리얼 출력 (상태 변경 후)
    Serial.print(millis());
    Serial.print(",");
    Serial.print(currentLevel);
    Serial.print(",");
    Serial.print(avgCurrent, 2);
    Serial.print(",");
    Serial.print(predictedLevel);
    Serial.print(",");
    Serial.println(isInStandby ? "Y" : "N");
    
    updateLCD(avgCurrent);
  }
}
